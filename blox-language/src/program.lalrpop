use std::str::FromStr;
use crate::ast;

grammar;

pub Program: ast::Program = {
  <statements: Statement*> => ast::Program { block: ast::Block { <> } }
};

Block: ast::Block = {
  "{" <statements: Statement*> "}" => ast::Block { <> }
}

Statement: ast::Statement = {
  "let" <lhs: Identifier> "=" <rhs: Expression> => ast::Statement::Binding { <> },
  FunctionCall => ast::Statement::FunctionCall(<>)
}

Identifier: ast::Identifier = {
  r"[a-zA-Z_]+" => ast::Identifier(<>.to_string())
}

Expression: ast::Expression = {
  <term: ExpressionTerm> => ast::Expression::Term(term),
  <lhs: ExpressionTerm> <operator: Operator> <rhs: ExpressionTerm> => ast::Expression::Operator { 
    lhs,
    operator, 
    rhs
  }
}

ExpressionTerm: ast::ExpressionTerm = {
  Literal => ast::ExpressionTerm::Literal(<>),
  Identifier => ast::ExpressionTerm::Identifier(<>),
  "(" <expr: Expression> ")" => ast::ExpressionTerm::Expression(Box::new(expr))
}

Literal: ast::Literal = {
  r"[0-9]+" => ast::Literal::Number(i64::from_str(<>).expect("parse error")),
  r"'[^']*'" => ast::Literal::String(<>[1..<>.len()-1].to_string())
}

Operator: ast::Operator = {
  "+" => ast::Operator::Add,
  "*" => ast::Operator::Multiply
}

FunctionCall: ast::FunctionCall = {
  <ident: Identifier> "(" <arguments: ArgumentList> ")" => ast::FunctionCall { <> }
}

ArgumentList: Vec<ast::Argument> = {
  Argument => vec![<>],
  <first:Argument> "," <rest:ArgumentList> => { 
    let mut list = vec![first];
    list.extend_from_slice(&rest);
    list
  }
}

Argument: ast::Argument = {
  <ident: Identifier> ":" <value: Expression> => ast::Argument { <> }
}